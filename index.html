<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LLMVis</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>LLMVis</h1>
  <div id="intro-section">
    <p>Visualize language models.</p>
    <div id="model-picker-row">
      <label for="model-picker">Model:</label>
      <select id="model-picker">
        <option value="markov">Markov Chain</option>
        <option value="eliza">ELIZA</option>
      </select>
    </div>
  </div>
  <div id="markov-container" style="display: block;">
    <h2>Markov Chain Visualizer</h2>
    <form id="markov-form" autocomplete="off" onsubmit="return false;">
      <textarea id="inputText" rows="6" cols="60" placeholder="Paste your training text here..."></textarea>
      <div class="markov-row single">
        <div class="markov-label-input">
          <label for="order">Order:</label>
          <input type="number" id="order" min="1" max="5" value="2">
        </div>
      </div>
      <div class="markov-row single">
        <div class="markov-label-input">
          <label for="seed">Seed:</label>
          <input type="text" id="seed" placeholder="(optional)">
        </div>
      </div>
      <div class="markov-row single">
        <div class="markov-label-input">
          <label for="maxWords">Max Words:</label>
          <input type="number" id="maxWords" value="50">
        </div>
      </div>
      <div id="output" style="margin:1em 0; min-height:2em;"></div>
      <div class="markov-row" id="markov-btn-row">
        <button id="trainBtn" type="button">Train Model</button>
        <button id="generateBtn" type="button" disabled>Generate Text</button>
      </div>
    </form>
    <canvas id="graphCanvas" style="display:block; margin-top:2em; background:#fff; border:1px solid #eee;"></canvas>
  </div>
  <div id="eliza-container" style="display: none;">
    <h2>ELIZA</h2>
    <div id="eliza-chat-area">
      <div id="eliza-chat-log"></div>
      <form id="eliza-input-area" autocomplete="off" onsubmit="return false;">
        <input type="text" id="eliza-input" placeholder="Say something to ELIZA..." autocomplete="off">
        <button id="eliza-send" type="submit">Send</button>
      </form>
    </div>
    <div id="eliza-match-path"></div>
    <div id="eliza-tree" style="display:block;"></div>
  </div>
  <script src="markov.js"></script>
  <script src="elizabot.js"></script>
  <script src="eliza.js"></script>
  <script>
    // Model picker logic
    const modelPicker = document.getElementById('model-picker');
    const markovContainer = document.getElementById('markov-container');
    const elizaContainer = document.getElementById('eliza-container');
    const elizaTree = document.getElementById('eliza-tree');
    const elizaCollapseBtn = document.getElementById('eliza-collapse-tree');
    modelPicker.addEventListener('change', function() {
      if (this.value === 'eliza') {
        markovContainer.style.display = 'none';
        elizaContainer.style.display = 'block';
        if (typeof renderMarkovVisualizer === 'function') {
          renderMarkovVisualizer();
        }
      } else {
        markovContainer.style.display = 'block';
        elizaContainer.style.display = 'none';
      }
    });

    // Collapsible tree state
    let elizaTreeState = { expanded: { 'ELIZA': true } };

    // Helper: get path to match (keyword, decomp, reasmb)
    function getElizaMatchPath(match) {
      if (!match) return [];
      return ['ELIZA', match.keyword, match.decomp, match.reasmb];
    }

    // Render ELIZA rule tree as collapsible, auto-expanding to matchPath
    function renderElizaTree(matchedPath) {
      const tree = window.buildElizaRuleTree();
      const container = document.getElementById('eliza-tree');
      function renderNode(node, path = []) {
        const isRoot = path.length === 0;
        const expanded = elizaTreeState.expanded[node.name] || isRoot;
        const highlight = matchedPath && matchedPath.includes(node.name);
        const isGoto = node.name && node.name.startsWith('goto ');
        const li = document.createElement('li');
        if (node.type === 'keyword') {
          li.setAttribute('data-eliza-keyword', node.name);
        }
        if (isGoto) {
          li.className = node.type + ' eliza-goto' + (highlight ? ' eliza-highlight' : '');
          const target = node.name.slice(5).trim();
          li.setAttribute('data-eliza-goto-target', target);
          li.innerHTML = `<span class="eliza-goto-arrow">â†ª</span> goto <b>${target}</b>`;
        } else {
          li.textContent = node.name;
          li.className = node.type + (highlight ? ' eliza-highlight' : '');
        }
        if (!expanded) li.classList.add('eliza-collapsible');
        li.onclick = (e) => {
          e.stopPropagation();
          elizaTreeState.expanded[node.name] = !expanded;
          renderElizaTree(matchedPath);
        };
        if (node.children && node.children.length && expanded) {
          const ul = document.createElement('ul');
          for (const child of node.children) {
            ul.appendChild(renderNode(child, path.concat(node.name)));
          }
          li.appendChild(ul);
        }
        return li;
      }
      container.innerHTML = '';
      const ul = document.createElement('ul');
      for (const child of tree.children) {
        ul.appendChild(renderNode(child));
      }
      container.appendChild(ul);
      // Draw visual links for gotos
      setTimeout(drawElizaGotoLinks, 0);
    }

    // Draw SVG arrows for gotos
    function drawElizaGotoLinks() {
      // Remove old SVG
      const oldSvg = document.getElementById('eliza-goto-svg');
      if (oldSvg) oldSvg.remove();
      const tree = document.getElementById('eliza-tree');
      const gotoNodes = tree.querySelectorAll('[data-eliza-goto-target]');
      if (!gotoNodes.length) return;
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('id', 'eliza-goto-svg');
      svg.style.position = 'absolute';
      svg.style.left = '0';
      svg.style.top = '0';
      svg.style.width = '100%';
      svg.style.height = tree.offsetHeight + 'px';
      svg.style.pointerEvents = 'none';
      tree.style.position = 'relative';
      // For each goto, draw an arrow to the target
      gotoNodes.forEach(gotoNode => {
        const targetKey = gotoNode.getAttribute('data-eliza-goto-target');
        const targetNode = tree.querySelector(`[data-eliza-keyword="${targetKey}"]`);
        if (!targetNode) return;
        const gotoRect = gotoNode.getBoundingClientRect();
        const targetRect = targetNode.getBoundingClientRect();
        const treeRect = tree.getBoundingClientRect();
        // Vertically center the arrow on both nodes
        const y1 = gotoRect.top + gotoRect.height/2 - treeRect.top;
        const y2 = targetRect.top + targetRect.height/2 - treeRect.top;
        // Start at right middle of goto, end at right middle of target
        const x1 = gotoRect.right - treeRect.left + 5;
        const x2 = targetRect.right - treeRect.left + 5;
        // Control point for rightward, flat approach
        const midX = Math.max(x1, x2) + 40;
        const midY = y2;
        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        arrow.setAttribute('d', `M${x1},${y1} Q${midX},${midY} ${x2},${y2}`);
        arrow.setAttribute('stroke', '#111');
        arrow.setAttribute('stroke-width', '2.5');
        arrow.setAttribute('fill', 'none');
        arrow.setAttribute('marker-end', 'url(#arrowhead)');
        svg.appendChild(arrow);
      });
      // Arrowhead marker
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('markerWidth', '8');
      marker.setAttribute('markerHeight', '8');
      marker.setAttribute('refX', '0');
      marker.setAttribute('refY', '4');
      marker.setAttribute('orient', 'auto-start-reverse');
      const arrowHead = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      arrowHead.setAttribute('points', '8,0 0,4 8,8');
      arrowHead.setAttribute('fill', '#111');
      marker.appendChild(arrowHead);
      defs.appendChild(marker);
      svg.appendChild(defs);
      tree.appendChild(svg);
    }

    // --- ELIZA Chat Bubble Logic ---
    const chatLog = document.getElementById('eliza-chat-log');
    const inputForm = document.getElementById('eliza-input-area');
    const inputBox = document.getElementById('eliza-input');
    function addChatBubble(text, sender) {
      const bubble = document.createElement('div');
      bubble.className = 'chat-bubble ' + (sender === 'eliza' ? 'eliza-bubble' : 'user-bubble');
      if (sender === 'eliza') {
        bubble.innerHTML = `<img src="eliza.png" alt="ELIZA" class="eliza-avatar"><span class="bubble-text">${text}</span>`;
      } else {
        bubble.innerHTML = `<span class="bubble-text">${text}</span>`;
      }
      chatLog.appendChild(bubble);
      chatLog.scrollTop = chatLog.scrollHeight;
    }
    // Initial ELIZA greeting
    addChatBubble((new ElizaBot()).getInitial(), 'eliza');

    inputForm.onsubmit = function() {
      const input = inputBox.value.trim();
      if (!input) return false;
      addChatBubble(input, 'user');
      inputBox.value = '';
      let match = window.elizaMatchPath(input);
      let response = '';
      let originalKeyword = match && match[0];
      // Follow gotos for highlighting and response
      function followGoto(match) {
        if (match && match[2] && typeof match[2] === 'string' && match[2].startsWith('goto ')) {
          const gotoKey = match[2].slice(5).trim();
          // Find the goto target match
          const gotoMatch = window.elizaMatchPath('goto:' + gotoKey);
          if (gotoMatch) return followGoto(gotoMatch);
        }
        return match;
      }
      match = followGoto(match);
      if (match) {
        elizaTreeState.expanded = { 'ELIZA': true };
        // Expand both the original and the goto target keyword
        if (originalKeyword) {
          elizaTreeState.expanded[originalKeyword] = true;
          // Expand all children of the original keyword
          const tree = window.buildElizaRuleTree();
          function findNodeByName(node, name) {
            if (node.name === name) return node;
            if (node.children) {
              for (const child of node.children) {
                const found = findNodeByName(child, name);
                if (found) return found;
              }
            }
            return null;
          }
          const origNode = findNodeByName(tree, originalKeyword);
          if (origNode && origNode.children) {
            for (const child of origNode.children) {
              elizaTreeState.expanded[child.name] = true;
            }
          }
        }
        if (match[0]) elizaTreeState.expanded[match[0]] = true;
        for (const name of match) {
          elizaTreeState.expanded[name] = true;
        }
        renderElizaTree(match);
        response = window.elizaSubstitute(match[2], match[3] || {}, match[4] || []);
        document.getElementById('eliza-match-path').innerHTML = `<b>Matched:</b> <br>Keyword: <code>${match[0]}</code><br>Decomp: <code>${match[1]}</code><br>Response: <code>${match[2]}</code>`;
      } else {
        response = '';
        document.getElementById('eliza-match-path').textContent = '';
      }
      setTimeout(() => addChatBubble(response, 'eliza'), 400);
      return false;
    };
    // Initial render
    renderElizaTree();
  </script>
</body>
</html> 